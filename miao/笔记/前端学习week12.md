---
title: 前端学习week12
date: 2019-07-21 20:34:15
comments: true
tags:
- front-end
- javascript
mathjax: false
---

​	学习时间正好三个月了， 本周学习了快排，这样排序算法就差堆排序没学了。本周的重点还是js的面向对象的概念，js除了几个基本数据类型(number,string,null,undefined)，其他的数组函数等都能视作对象，甚至基本数据类型也有包装对象的概念。要理解js的面向对象，原型和原型属性是非常重要的知识点，要理清数据类型的原型几个构造函数的原型属性之间的关系，接着是自定义构造函数

<!-- more -->

##### 排序

- sort方法的函数值参数为什么用两个参数，而不是一个？
  - 一个参数局限性大，两个更灵活，sort内部实现根据箭头函数的返回值来对元素排序，可以自定义排序条件
- 排序算法的稳定性：
  - 排序前后不改变相同元素的相对位置
  - 稳定：
    - 冒泡
    - 归并
    - 插入/BST
    - 返回新数组的快排
  - 不稳定：
    - 选择排序
    - 原地快排
- 快排
  - 主要思想是先随机取一个位置的数，将大于，等于， 小于它的数分组，再递归
    - 切分不平衡可能使排序效率较低，一个解决办法是排序前先将数组随机打乱
  - 当数组中所有数都相同时，时间复杂度会退化为n * n，调用栈也会达到n层
  - 小数组时快排比插入排序慢
  - 原地快排将取样元素放在数组末尾作为哨兵来优化partition

### 深入理解对象

- 方法中的this指向当前方法所属的对象，相当于函数的隐含参数
  - eg: apply() bind() 
- this 是对象中的一个特殊变量
- 箭头函数根据当前的[词法作用域](http://www.cnblogs.com/xiaohuochai/p/5700095.html)而不是根据[this机制顺序](http://www.cnblogs.com/xiaohuochai/p/5737435.html)来决定this，所以，箭头函数会继承外层函数调用的this绑定，而无论this绑定到什么，且**不能改变**箭头函数的this绑定，可以当做箭头函数没有this
- 箭头函数不能用做构造函数，即其没有原型属性
- 箭头函数没有arguments属性

#### 原型

- 对象都包含一个原型，原型也是一个对象，原型也有原型。。。Object.prototype是所有对象原型的父原型
  - `Object.prototype.__proto__`结果为`null`
- 访问对象中不存在的属性，会在其原型中搜索，接着是原型的原型，以此类推
  - 访问属性的优先级 对象自身 > 原型
  - 即对象和原型有同名属性有限调用对象自身的属性
- `Object.getPrototypeOf()`获取对象的原型
- `Object.creat(prototype)`以原型创建对象
  - 传入null创建无原型对象
- 原型和原型属性
  - 对象的原型：`obj.__proto__`
  - 原型属性： 每个函数（且一般只有函数才有）都有一个**原型属性** `f.prototype`
    - 原型属性是一个对象，对象内的属性包含构造器标识（即这个函数）， 以及实例能调用的方法
      - 函数对象本身的属性可以在构造器标识内查看，这是实例不能调用的
      - 即实例的constructor属性可以查看这个实例的构造函数
    - 这个概念是针对构造函数来说的，可以理解为本来有的原型基础上的衍生原型（添加了自己定义的属性），就是它会作为这个构造函数的实例的原型
    - 因此`f.prototype.xxx`可以给构造函数的原型属性添加属性，这样这个构造函数的实例就能使用这个属性
      - 可枚举/不可枚举属性，默认创建的是可枚举（会出现在for/in循环中，不可枚举属性不会，但是可以用in返回true）
    - 原型属性是一个对象， 创建的实例的原型指向这个对象，修改构造函数的原型属性指向的对象，在这之前创建的实例的原型指向不会变
  - `Object.prototype.toString()`判断包装类型

#### 包装类型

- **每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据**
- 自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后立即被销毁了。这就意味着，不能在运行时为基本类型值添加属性和方法。

#### 构造函数

- 调用函数前用`new`表示调用其构造函数
  - new一定会返回对象，当构造函数返回的不是对象则会被忽略
  - 注意用不用new的区别，不用new相当于给当前作用域的活动对象添加属性
- 通过`new`创建的对象称为构造对象的**实例**
- `instanceof`判断实例是不是某个构造函数（或者继承的父构造函数）创建的

#### 面向对象

- 表达一个事物是离散存放的
- 封装： 把表达一个事务的最终信息及可能的操作（即函数）放在一起
- 同一类对象有相同的一组属性和一组函数
- 继承：让一个类直接获取另一个类所有的属性和方法
- 多态：不关心得到的事物具体是什么类别，更关心这个事物是否有某方面特性(有特定的一组属性和方法)

#### class

- [Javascript 类](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes)

- 创建的方法不可枚举

- ```js
  class A {
  	static a(){}
  	static b(){}
  	constructor(){}
  	method1(){}
  	method2(){}
  	get length(){}
  	set length(val){}
  }
  typeof A == function
  ```

#### 零碎知识

- 判断类型
  - `typeof ` 用来判断原始类型
  - `Object.prototype.toString.call`判断内置对象类型
  - `instanceof`判断自定义对象类型  
- `new.target === f`判断f是否正在被new调用
- `Object.defineProperty(obj, 'name', {})`给对象/原型添加属性
  - `{}`内依次为value，get，set，enumerable， writable， configurable
  - value和（get，set）只能出现一个
- 直接给原型赋值对象， `name.protorype = {constructor: name,  xxxxx}`
- 用`Array.prototype.slice().call(arguments)`在函数中创建参数的数组（arguments是类数组不能直接用数组方法），也可以用`[].slice().call(arguments)`