---
title: 前端学习week10
date: 2019-07-07 20:35:01
comments: true
tags:
- javascript
- front-end
mathjax: false
---

​	本周主要学习了数组和对象这两种数据结构，在js中，除了集中原始值，其他数据结构都能视作对象，另外简单介绍了一下链表，js中的链表结构比较简单，操作也很方便。需要理解的是对象标识符指向对象的存储地址(这也比其他语言简单很多)，另外就是js数组和字符串的一些方法函数，需要在使用中加强记忆。

<!-- more -->



#### UTF-8 变长编码

- 第一个字节的前几位表示这个字符占用多少个字节
  - 一个字节01xxxxxx
  - 两个字节110xxxxx
  - 三个字节1110xxxx
  - 四个字节11110xxx
- 之后的每个字节的都是10开头，因此不同字节长度实际存储该字符所占二进制位：
  - 一个字节： 6
  - 两个： 5 + 6 
  - 三个： 4 + 6 + 6
  - 四个： 3 + 6 + 6 + 6
- 特点：
  - 变长
  - 兼容标准ASCII
  - 容错



#### 数组和对象

- 读取null和undefined的属性会报错
- 用`.`和`[]`都可以方问属性，但是点后直接跟属性名，方括号会计算其中的表达式并把返回值作为属性名
  - 属性名是字符串
  - 可以使用方括号访问数字或带空格的字符串作为属性名的属性
- 数组是值的有序集合，对象是值的具名集合
- `delete obj.a`  一元运算符   删除对象中的a属性
- `str in obj` 二元运算符  返回布尔值，对象中是否有这个属性
  - in用在数组中是检测这个位置是否为**空**，并不是是否存有这个值
- indexOf只能检索大于等于0的整数下标，其他都返回-1
- `for (name in obj)`  遍历对象的属性 ，属性名字符串传给name   
  - 这里的in不是运算符
- 对象的浅比较和深比较
  - == 和 === 比较的是对象是否是同一个引用
  - 深比较是比较属性和值是否相同而不论是否是同一个引用，js没有深比较的api，需要自己实现
- 一些数组的方法
  - fill(item, start, end)  填充，不包括end位置，start和end都省略则填充empty
  - flat()   展开一级，返回新数组  里面有对象不展开
  - include(value)  判断数组中是否有这个值，返回布尔值   不能判断对象，除非是同一个引用
- 给原始值添加对象和读取对象，不会报错但会读取undefined，可以用Object()创建原始类型(对象)的包装对象(一个真实的对象包装了一个原始类型)     不建议使用
- 字符串的trim()方法，删除开头和结尾的空白符号(空格，换行，制表等)
- arguments对象很像数组，有length属性， 但不包含任何数组方法， 是一个类数组对象
- 类数组对象：任何一个具有length属性以及对应非负整数属性的对象
  - 类数组对象不能直接使用数组方法，但是可以`Array.methods.call(obj, xxx)`调用数组方法
- ` Array.from()` 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例
- `...`省略号运算符
  - rest parameter  剩余参数，只能出现一次且只能出现在形参最后
  - spread operator  展开数组和对象，展开对象时只能用在创建对象和数组的字面量时使用，因为展开形式为对象中属性及对应值的表达式
- 可以给形参赋值作为缺省的默认值



#### 零碎知识

- 递归四条准则
  - 基准情形
  - 不断推进
  - 设计法则
  - 合成效益法则
  
  使用递归时注意递归过程中**重复计算**的问题，可以储存各计算结果当遇到这个计算时直接返回值
  
  不要使用全局变量(除非刻意要用)
  
  注意返回新对象还是在原对象上操作的一致性
  
- document.write()
  - 向文档解析流写入内容
  - 文档一旦解析完成`</html>`，解析流关闭
  - 重新write会导致重新打开一个解析流，之前的内容完全覆盖
  
- 排序算法
  - 希尔shell排序
    - 希尔排序的思想是 将原数组中间隔h的子数组使用插入排序，循环减少h至h=1即排序完成
    - 实际是插入排序的优化版，能将离本来位置较远的元素更快地移动到本来的位置
    - 实际使用中是性能最好的初级排序

