---
title: 前端学习week13
date: 2019-07-28 23:00:44
comments: true
tags:
- front-end
- javascript
mathjax: false
---

​	本周学习了最后一个常用排序算法-堆排序以及一些哈希表的基本概念，理解其思想和使用情景即可。js基础学习了异常处理和严格模式。红黑树没看完，只看完了基本概念，下周补完

<!-- more -->

#### 堆，堆排序

- 堆(heap)是一种数据结构，也叫优先序列(PriorityQueue)
- 区别于"堆内存(heap memeory)"的堆
  - 堆内存对应栈内存
    - 堆内存是随机分配的
    - 栈内存对应调用栈
  - 栈空间指一片内存
  - 调用栈指函数间互相调用及等待的逻辑概念
- 堆是一棵完全二叉树
  - 每个结点都比其子节点大(小)
  - 最大/最小堆 (最大/最小值一定处于堆顶)
  - 主要支持两种操作
    - 增加一个元素
    - 取出其最值
    - 操作不影响堆的性质
- 堆排序是将长度为n堆数组的第一个值交换到最后，再将前n-1个数的数组堆化，直到数组有序
- 堆尾增加一个元素： heapUp
- 堆头增加一个元素： heapDown
  - 例：取出堆的最值，将堆尾元素放在头部重建为堆
- 将一个无序数组转换为堆：
  - 将数组当做按层遍历的二叉树，从末尾最小的二叉树头结点（最后一个元素的父节点）做heapDown操作，循环至堆头
- 找出第k大的元素，构建一个大小为k的最小堆

#### 异常处理

- try(throw)--catch--finally
  - catch捕获的看前面throw的是什么，默认的错误是一个对象，因为是Error()的实例
  - 编译器先确定程序没有**语法错误**才开始执行
  - throw立即停止运行直到被catch
- Error()是构造函数

##### 严格模式

- `"use strict"`
- 静默错误现在会抛出异常
- 不允许不声明创建全局变量
- 只限定当前作用域下的代码，不限制调用的函数
- 直接调用方法/构造函数，this绑定undefined而不是window
- 函数形参名唯一
- 不能使用八进制字面量(即0开头的数字类型)，但可以写成`0oxxx`
- 不允许直接使用eval()在当前作用域中创建变量或函数
  - 在严格模式下，`eval()`在运行时有自己的词法作用域，意味着其中的声明无法修改所在的作用域，但是可以获取eval()内语句块的返回值
- 不能覆写arguments的值
- es6一些语法会自动开启es6模式，例：class
- 带有“非简单参数”的函数为不能包含 "use strict" 指令
  - 默认参数值
  - 剩余参数
  - 参数解构
  - 因为这些是es6新增的参数语法，"use strict"不认识，在es6模式下如class等没有问题
  - [带有“非简单参数”的函数为什么不能包含 "use strict" 指令](https://www.cnblogs.com/ziyunfei/p/5926123.html)



#### 哈希表(散列表)

##### 哈希函数

- 散列函数生成的值要尽可能随机且均匀分布

##### 哈希冲突

即不同key经过哈希函数计算出相同的值，很难通过完善算法的方式完美解决，所以需要其他的途径

- 开放寻址法
  - 如果出现了冲突，就重新探测一个空闲位置将其插入
    - 线性探测		步长为1
    - 二次探测        步长为平方
    - 双重散列        冲突则再哈希一次
  - 装载因子： 填入表中的元素个数 / 散列表的长度
    - 装载因子越大，空闲位置越少，散列表性能越低
    - 动态扩容/缩容，设置阈值保持执行效率
- 链表法
  - 每个slot对应一条链表，hash值相同则直接加入链表末尾



#### 平衡二叉查找树

严格的平衡二叉查找树是指这棵二叉查找树任意结点的左右子树高度差不能大于1，使树的高度保持以2为底logN

设计平衡二叉查找树的初衷是为了防止频繁的插入和删除操作造成的性能退化，常见的平衡二叉查找树：

- AVL树：严格符合以上定义，是高度平衡的二叉查找树
- 红黑树(R-B tree)：不严格符合高度差为1的定义，但是能思想是一样的，即保持左右子树高度大致相等，所以也认为是合格的平衡二叉查找树，很多种平衡二叉查找树都不严格符合定义
  - 定义：
    - 根结点是黑色
    - 每个叶子是黑色的空结点NIL
    - 相邻结点不能同时为红色，即红色结点被黑色结点隔开
    - *从任意结点到达其可到达的叶子结点路径经过的黑色结点的数量是相同的
  - 红黑树是“近似平衡”的(即性能不会退化地太严重，树的高度稳定地趋近以2为底logN)
  - 插入操作
    - 插入结点必须是红色，新插入的结点放在叶子结点上
    - 旋转
    - 变色
  - 删除操作

#### 零碎知识

- 浅拷贝和深拷贝

  - 浅拷贝只复制对象的第一层
  - 深拷贝递归复制所有层级

- 直接调用eval()是在当前作用域下调用，凡是使用别名调用eval()则一律是在全局作用域下

- 函数表达式的函数名是常量绑定，只在该函数内部有效，在函数内对其赋值在非严格模式下会静默失败，严格模式下会报错

  - ```js
    (function a() {
        a = 3
        console.log(a)
    })()
    //会打印出整个函数体
    //可以理解为a函数相当于const定义的常量
    ```

  - 注意函数声明提升https://blog.csdn.net/sinat_35512245/article/details/53514804

  - 函数表达式可以后面加括号立即调用，函数声明不可以

  - 给函数声明整体加括号相当于将函数声明转换为函数表达式，就可以立即调用了

    - 两种立即执行函数的写法`( function(){…} )()`和`( function (){…} () )`

- call 比 apply的性能更好，因为传入的参数是函数需要的格式

- 对象中若有splice属性存放数组的splice方法以及length属性，会自动转为`object []`形式

- dot notation比用[]读取对象的属性性能好

- for的性能远高于forEach

  - 因为for循环没有额外的函数调用栈和上下文
  - forEach里操作了toObject以及循环终止等逻辑更加复杂

