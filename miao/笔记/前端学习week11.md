---
title: 前端学习week11
date: 2019-07-14 22:47:24
comments: true
tags:
- javascript
- front-end
mathjax: false
---

​	本周主要学习了js高阶函数的用法，可以将函数作为参数传入另一个函数使用，熟悉几个自带的数组方法函数，另外简单介绍了一下JSON。数据结构学习了二叉树，前中后序遍历，搜索二叉树的性质，增删结点，加深理解还是要靠刷题。

<!-- more -->

#### 高阶函数

- `_`实参占位符
- 以函数值为实参没有产生闭包
- 函数的length属性返回形参的个数，name属性返回函数名

##### 传参

- 函数的apply方法，将数组或类数组作为单独参数传入，防止多余的参数被忽略

  - 现在一般用省略号

- 数组以函数为参数的方法

  - forEach

    - 一个函数参数， 只是对各元素进行操作，没有返回值，`forEach`不直接改变调用它的对象，但是对象可能会被`callback`改变
    - 只遍历存在的项，empty不遍历
    - 除了抛出异常无法阻止forEach

  - filter

    - 一个函数参数，返回包含通过测试的元素的新数组

  - map

    - 一个函数参数，返回回调函数的结果的新数组

  - reduce

    - 一个函数参数，数组第一项作为初始值，初始值变量分别和数组剩下的每个值会作为操作函数的参数，返回最后迭代后的值
    - 初始值可选，如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错
    - 函数参数前一个形参是累计器，后一个是数组元素

  - 实际上前三个方法传入的参数为三个，分别为

    - Current Value (cur) (当前值)
    - Current Index (idx) (当前索引)
    - Source Array (src) (源数组)

    reduce在最前面还有一个Accumulator (acc) (累计器)

    给函数参数传入的参数也是这几个参数，所以需要**注意**接受多余的参数是什么，会造成什么后果，怎么利用

- 函数值参数可简写为箭头函数

  - 只有一个参数时可以省略括号
  - 只有一个return语句时可省略return和花括号
  
- 函数的方法：

  - `bind(null, xx,xx)`，返回一个新的函数，相当于在原函数内给对应位置的参数附值绑定，返回的新函数就没有这个形参了，null后紧接着原函数的第一个参数，以此类推

  - ```js
    function bind(f) {
        var fixedArgs = Array.from(arguments).slice(1)
        return function() {
            var args = Array.from(arguments)
            return f.apply(null, fixedArgs.concat(args))
        }
    }
    ```

  - `apply`方法，用数组来指定函数的参数

##### JSON

Javascript Object Notation

- 属性名必须用双引号，只能包含简单的数据表达式，不能包含注释
- parse 和 stringify函数
- 没有undefined
- 不能出现明文tab符
- 不能出现多余符号



#### 二叉树

- 完全二叉树
- 前pre/中in/后序post遍历 traversal
- 排序二叉树BST
  - 结点左结点的值小，右结点的值大
  - 中序遍历，得到有序序列    是一种**插入排序**，利用这点可以很快地判断是否为BST，是BST很重要的一个性质
  - 添加结点
  - 删除结点

#### 零碎知识

- toString方法可以将数字转为2-36进制的字符串

- sort()方法默认情况下按照升序排列数组项，sort()方法会调用toString()转型方法，然后比较得到的字符串，即使我们比较的是数字，他也会**把数字转为字符串以后再排序**

- 关于动态规划(dynamic programming)的理解
  - 每个阶段只有一个状态->递推；
  - 每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
  - 每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
  - 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。
  - 动态规划的三个组成：**最优子结构**，**边界**， **状态转移**
  - 递归是自顶向下的，而动态规划的本质是自底向上的
  - 解决动态规划/递归中的重复计算
    - “备忘录算法”：将递归中计算过的值存入哈希表
    - 自底向上递推，动态存储下次计算需要的状态
  
- 归并排序
  - 基本思想是将数组递归地分成两半分别排序，再将结果归并
  - 优化： 
    - 小规模子数组可以使用插入排序
    - 增加一个判断：`arr[mid] < arr[mid + 1]`时可认为数组已经有序，跳过merge，直接连接
  - 一般是自顶向下的方法，也可自底向上两两归并，四四归并。。。。这种方式适合处理链表原地排序
  
- 数组的includes方法可以正确判断NaN，indexOf不行

- `Array.from()将类数组对象转为数组`

- **arguments** 是一个对应于传递给函数的参数的**类数组对象**

  